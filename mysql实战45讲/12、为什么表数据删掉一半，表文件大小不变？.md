# 问题
1. 数据库表的空间回收
2. 数据的空洞
3. 解决空洞的问题

# 数据库表的空间回收
```
innodb_file_per_table设置为ON
我们在使用delete命令把数据删除的时候，对该表来说占用的磁盘大小是不会减少的，因为对表空间的回收不是使用delete去做的
innodb_file_per_table：数据既可以在共享表空间，也可以是单独文件。把这个参数值设置为ON，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中
    一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。
```

# 数据的空洞
```
InnoDB 里的数据都是用 B+ 树的结构组织的。
delete命令只是把记录的位置或者数据页标记为了"可复用"，但是磁盘文件的大小是不会变的
delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”
insert如果是随机插入的，可以造成索引的数据页分裂，也会产生数据的空洞
update可以理解为删除一个旧的值，再插入一个新的值，也会产生数据的空洞
```

# 数据库表的空间回收
- 经过大量增删改的表，都是可能是存在空洞的，这些空洞就导致表的文件大小不变
- 重建表可以把这些空洞去掉，就能达到收缩表空间的目的
  - 非online方式
    - 新建一个表，然后把数据一行一行的读出来插入进去
    - MySQL5.6之前，alter table A engine=InnoDB，就是类似新建一个表导过去的方式进行重建，存在加写锁会阻塞CRUD的操作
  - online方式
    - MySQL5.6之后，alter table A engine=InnoDB，这个写锁在真正拷贝数据之前就退化成读锁了，执行期间可以接受增删改操作
  - 开源的 gh-ost
    - 上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗 IO 和 CPU 资源的